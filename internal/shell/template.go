package shell

// mainScriptTemplate is the main body of the installer script.
// It performs runtime detection and resolution.
const mainScriptTemplate = `#!/bin/sh
set -e
# Code generated by binstaller ({{ .BinstallerVersion }}) from {{ .SourceInfo }}. DO NOT EDIT.
#

# --- Configuration from Spec (Embedded via Go Template) ---
SPEC_NAME="{{ .Name }}"
SPEC_REPO="{{ .Repo }}"
SPEC_DEFAULT_VERSION="{{ .DefaultVersion | default "latest" }}"
SPEC_ASSET_TEMPLATE="{{ .EscapedAssetTemplate }}" # Use the escaped template directly
SPEC_DEFAULT_EXTENSION="{{ .Asset.DefaultExtension | default "latest" }}"
# TODO: Embed Asset Rules, Aliases, Naming Convention as shell variables/functions
# Example (requires more complex Go templating):
# SPEC_OS_ALIAS_darwin="macOS"
# SPEC_ARCH_ALIAS_amd64="x86_64"
SPEC_NAMING_CONVENTION_OS="{{ .Asset.NamingConvention.OS | default "lowercase" }}" # Embed naming convention OS
# SPEC_RULE_1_WHEN_OS="windows"
# SPEC_RULE_1_EXT=".zip"

SPEC_CHECKSUM_TEMPLATE="{{ .EscapedChecksumTemplate }}" # Use the escaped template directly
SPEC_CHECKSUM_ALGO="{{ if .Checksums }}{{ .Checksums.Algorithm | default "sha256" }}{{ else }}sha256{{ end }}"
# TODO: Embed Checksums Map (requires complex Go templating or JSON embedding + jq)
# Example: EMBEDDED_CHECKSUMS_v1_2_3_foo_linux_amd64_tar_gz="hash..."

SPEC_STRIP_COMPONENTS={{ if .Unpack }}{{ .Unpack.StripComponents | default 0 }}{{ else }}0{{ end }}
# TODO: Embed Attestation settings

# --- Shell Function Library ---
{{ .ShellFunctions }}
# --- End Shell Function Library ---


usage() {
  this=$1
  cat <<EOF
$this: download ${SPEC_NAME} from ${SPEC_REPO}

Usage: $this [-b bindir] [-d] [-t tag]
  -b sets bindir or installation directory, Defaults to ./bin
  -d turns on debug logging
  -t specific tag to install (defaults to '${SPEC_DEFAULT_VERSION}')
  # TODO: Add flags for variant selection?
  # TODO: Add flags for attestation?

 Generated by binstaller ({{ .BinstallerVersion }})
  https://github.com/haya14busa/binstaller # TODO: Update URL?

EOF
  exit 2
}

parse_args() {
  # Default values
  BINDIR="./bin"
  TAG="${SPEC_DEFAULT_VERSION}" # Default to spec default version
  # TODO: Set default attestation flags based on spec

  while getopts "b:dt:h?x" arg; do
    case "$arg" in
      b) BINDIR="$OPTARG" ;;
      d) log_set_priority 7 ;; # Use 7 for debug in shlib
      t) TAG="$OPTARG" ;;      # Allow tag override via flag
      h | \?) usage "$0" ;;
      x) set -x ;;
      # TODO: Add attestation/variant flags
    esac
  done
  shift $((OPTIND - 1))
}

# --- Helper functions for runtime resolution ---

# substitute_placeholders replaces ${VAR} style placeholders
# $1: template string
# $2: NAME
# $3: VERSION
# $4: TAG
# $5: OS
# $6: ARCH
# $7: VARIANT
# $8: EXT
substitute_placeholders() {
  _tmpl=$1
  _name=$2
  _version=$3
  _tag=$4
  _os=$5
  _arch=$6
  _variant=$7
  _ext=$8

  log_debug "Substituting template: ${_tmpl}"
  log_debug "  NAME=${_name}"
  log_debug "  VERSION=${_version}"
  log_debug "  TAG=${_tag}"
  log_debug "  OS=${_os}"
  log_debug "  ARCH=${_arch}"
  log_debug "  VARIANT=${_variant}"
  log_debug "  EXT=${_ext}"

  # Use printf and chained sed for substitution. Handle potential slashes in values.
  # Using a separator other than / for sed, e.g., #
  _result=$(printf "%s" "${_tmpl}" | sed \
    -e "s#\${NAME}#${_name}#g" \
    -e "s#\${VERSION}#${_version}#g" \
    -e "s#\${TAG}#${_tag}#g" \
    -e "s#\${OS}#${_os}#g" \
    -e "s#\${ARCH}#${_arch}#g" \
    -e "s#\${VARIANT}#${_variant}#g" \
    -e "s#\${EXT}#${_ext}#g" )

  log_debug "Substitution result: ${_result}"

  # Check for unsubstituted placeholders (using POSIX ERE)
  if printf "%s\n" "${_result}" | grep -q -E '\$\{([A-Za-z0-9_]+)\}'; then
    log_err "Warning: Potential unsubstituted placeholder found in result: ${_result}"
  fi
  printf "%s\n" "${_result}" # Use printf for safer output
}

# apply_platform_mapping applies aliases and naming conventions
# $1: OS (input)
# $2: Arch (input)
# Outputs space-separated OS Arch
apply_platform_mapping() {
  _os_in=$1
  _arch_in=$2
  _os_out=$_os_in
  _arch_out=$_arch_in

  # TODO: Embed Alias maps from spec and apply them here using shell variables
  # Example:
  # _alias_var="SPEC_OS_ALIAS_${_os_out}"
  # if [ -n "${!_alias_var}" ]; then _os_out="${!_alias_var}"; fi
  # _alias_var="SPEC_ARCH_ALIAS_${_arch_out}"
  # if [ -n "${!_alias_var}" ]; then _arch_out="${!_alias_var}"; fi

  # Apply NamingConvention from spec
  case "$SPEC_NAMING_CONVENTION_OS" in
      "lowercase")
          _os_out=$(echo "$_os_out" | tr '[:upper:]' '[:lower:]')
          ;;
      "titlecase")
          # Basic title casing in shell
          _os_out=$(echo "$_os_out" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')
          ;;
      *)
          # Default to lowercase if convention is unknown or not set
          _os_out=$(echo "$_os_out" | tr '[:upper:]' '[:lower:]')
          ;;
  esac
  # Arch is always lowercase according to spec v1
  _arch_out=$(echo "$_arch_out" | tr '[:upper:]' '[:lower:]')

  echo "$_os_out $_arch_out"
}

# resolve_asset resolves asset details at runtime
# $1: OS
# $2: Arch
# $3: Variant
# $4: Version
# $5: Tag
# Outputs space-separated: AssetFilename AssetExt ChecksumFilename StripComponents
resolve_asset() {
  _os=$1
  _arch=$2
  _variant=$3
  _version=$4
  _tag=$5

  _asset_template="${SPEC_ASSET_TEMPLATE}"
  _checksum_template="${SPEC_CHECKSUM_TEMPLATE}"
  _asset_ext="" # Default
  _strip_components=${SPEC_STRIP_COMPONENTS}

  # TODO: Embed Asset Rules from spec and implement matching logic here
  # Example (requires embedding rules):
  # if [ "$_os" = "$SPEC_RULE_1_WHEN_OS" ]; then _asset_ext="$SPEC_RULE_1_EXT"; fi

  # Determine final extension
  _final_ext=$_asset_ext
  if [ -z "$_final_ext" ]; then
     # If no extension override, use the default extension from the spec
     _final_ext="${SPEC_DEFAULT_EXTENSION}"
     log_debug "No extension override, using default extension: ${_final_ext}"
  fi

  # Substitute placeholders using the resolved values
  _asset_filename=$(substitute_placeholders \
      "${_asset_template}" \
      "${SPEC_NAME}" \
      "${_version}" \
      "${_tag}" \
      "${_os}" \
      "${_arch}" \
      "${_variant}" \
      "${_final_ext}")

  # Ensure final extension is correct
  # TODO: Improve extension handling logic
  _current_ext=""
  case "$_asset_filename" in
     *.tar.gz|*.tgz|*.zip|*.tar) ;; # Already has known extension
     *) # Add extension if needed and determined
        if [ -n "$_final_ext" ]; then
           _asset_filename="${_asset_filename}${_final_ext}"
        fi
     ;;
  esac


  _checksum_filename=""
  if [ -n "$_checksum_template" ]; then
     log_debug "Calling substitute_placeholders for checksum filename"
     log_debug "  Template: ${_checksum_template}"
     _checksum_filename=$(substitute_placeholders \
         "${_checksum_template}" \
         "${SPEC_NAME}" \
         "${_version}" \
         "${_tag}" \
         "${_os}" \
         "${_arch}" \
         "${_variant}" \
         "${_final_ext}") # Use final_ext here too? Or does checksum have its own? Assume final_ext for now.
     log_debug "Resulting checksum filename: ${_checksum_filename}"
  fi

  echo "$_asset_filename $_final_ext $_checksum_filename $_strip_components"
}

# find_embedded_checksum looks for a checksum in embedded data
# $1: Version
# $2: Asset Filename
# Outputs the hash if found, otherwise empty string
find_embedded_checksum() {
  _version=$1
  _asset_filename=$2
  _hash=""
  # TODO: Embed checksum map from spec and implement lookup logic here
  # Example (requires embedding data as shell variables):
  # _key_v="EMBEDDED_CHECKSUMS_v${_version}_${_asset_filename}" # Need to sanitize filename for var name
  # _key="EMBEDDED_CHECKSUMS_${_version}_${_asset_filename}"
  # if [ -n "${!_key_v}" ]; then _hash="${!_key_v}";
  # elif [ -n "${!_key}" ]; then _hash="${!_key}"; fi
  echo "$_hash"
}


# TODO: Adapt verify_attestation function if needed

# --- Main Execution ---
execute() {
  # --- Determine target platform ---
  OS=$(uname_os)
  ARCH=$(uname_arch)
  # TODO: Handle VARIANT detection/selection

  # --- Validate platform ---
  uname_os_check "$OS"
  uname_arch_check "$ARCH"
  # TODO: Check if determined OS/ARCH/VARIANT is in .SupportedPlatforms if provided

  log_info "Detected Platform: ${OS}/${ARCH}" # TODO: Add VARIANT

  # --- Apply Platform Mapping ---
  # TODO: Implement apply_platform_mapping based on embedded spec data
  mapped_platform=$(apply_platform_mapping "$OS" "$ARCH")
  OS_MAPPED=$(echo "$mapped_platform" | cut -d' ' -f1)
  ARCH_MAPPED=$(echo "$mapped_platform" | cut -d' ' -f2)
  log_debug "Mapped Platform: ${OS_MAPPED}/${ARCH_MAPPED}"

  # --- Determine Version ---
  log_info "Selected tag: ${TAG}"
  if [ "$TAG" = "latest" ]; then
    REALTAG=$(github_release "${SPEC_REPO}" "latest") || exit 1
    test -n "$REALTAG" || { log_crit "Could not determine latest tag for ${SPEC_REPO}"; exit 1; }
  else
    # Assume TAG is a valid tag/version string
    REALTAG="$TAG"
  fi
  VERSION=${REALTAG#v} # Strip leading 'v'
  TAG="$REALTAG"       # Use the resolved tag
  log_info "Resolved version: ${VERSION} (tag: ${TAG})"

  # --- Resolve Asset Details ---
  # TODO: Pass variant to resolve_asset when implemented
  resolved_details=$(resolve_asset "$OS_MAPPED" "$ARCH_MAPPED" "" "$VERSION" "$TAG")
  ASSET_FILENAME=$(echo "$resolved_details" | cut -d' ' -f1)
  # ASSET_EXT=$(echo "$resolved_details" | cut -d' ' -f2) # Not currently used directly
  CHECKSUM_FILENAME=$(echo "$resolved_details" | cut -d' ' -f3)
  STRIP_COMPONENTS=$(echo "$resolved_details" | cut -d' ' -f4)

  # --- Construct URLs ---
  # TODO: Make base URL configurable?
  GITHUB_DOWNLOAD="https://github.com/${SPEC_REPO}/releases/download"
  ASSET_URL="${GITHUB_DOWNLOAD}/${TAG}/${ASSET_FILENAME}"
  CHECKSUM_URL=""
  if [ -n "$CHECKSUM_FILENAME" ]; then
    CHECKSUM_URL="${GITHUB_DOWNLOAD}/${TAG}/${CHECKSUM_FILENAME}"
  fi

  log_info "Asset URL: ${ASSET_URL}"
  if [ -n "$CHECKSUM_URL" ]; then
    log_info "Checksum URL: ${CHECKSUM_URL}"
  fi

  # --- Download and Verify ---
  tmpdir=$(mktemp -d)
  log_debug "Downloading files into ${tmpdir}"
  log_info "Downloading ${ASSET_FILENAME} from ${ASSET_URL}"
  http_download "${tmpdir}/${ASSET_FILENAME}" "${ASSET_URL}" || { rm -rf "${tmpdir}"; exit 1; }

  # Checksum Verification
  CHECKSUM_HASH=$(find_embedded_checksum "$VERSION" "$ASSET_FILENAME")
  CHECKSUM_ALGO="${SPEC_CHECKSUM_ALGO}"

  if [ -n "$CHECKSUM_HASH" ]; then
    # Embedded checksum available
    log_info "Verifying embedded checksum (${CHECKSUM_ALGO})..."
    echo "${CHECKSUM_HASH}  ${ASSET_FILENAME}" > "${tmpdir}/embedded_checksum.txt"
    hash_sha256_verify "${tmpdir}/${ASSET_FILENAME}" "${tmpdir}/embedded_checksum.txt" || { rm -rf "${tmpdir}"; exit 1; } # TODO: Use CHECKSUM_ALGO
    rm "${tmpdir}/embedded_checksum.txt"
  elif [ -n "$CHECKSUM_URL" ]; then
    # Download checksum file
    log_info "Downloading checksums from ${CHECKSUM_URL}"
    http_download "${tmpdir}/${CHECKSUM_FILENAME}" "${CHECKSUM_URL}" || { rm -rf "${tmpdir}"; exit 1; }
    log_info "Verifying checksum (${CHECKSUM_ALGO})..."
    hash_sha256_verify "${tmpdir}/${ASSET_FILENAME}" "${tmpdir}/${CHECKSUM_FILENAME}" || { rm -rf "${tmpdir}"; exit 1; } # TODO: Use CHECKSUM_ALGO
  else
    log_info "No checksum URL or embedded hash found, skipping verification."
  fi

  # TODO: Attestation Verification

  # --- Extract and Install ---
  log_info "Extracting ${ASSET_FILENAME}..."
  (cd "${tmpdir}" && untar "${ASSET_FILENAME}" "${STRIP_COMPONENTS}") || { rm -rf "${tmpdir}"; exit 1; }

  # Determine binary name based on spec
  BINARY_NAME="${SPEC_NAME}"
  INSTALL_BIN_NAME="$BINARY_NAME"
  if [ "$OS" = "windows" ]; then
     case "$INSTALL_BIN_NAME" in *.exe) ;; *) INSTALL_BIN_NAME="${INSTALL_BIN_NAME}.exe" ;; esac
  fi

  # Find the binary
  extracted_binary_path=""
  if [ -f "${tmpdir}/${BINARY_NAME}" ]; then
     extracted_binary_path="${tmpdir}/${BINARY_NAME}"
  elif [ "$OS" = "windows" ] && [ -f "${tmpdir}/${BINARY_NAME}.exe" ]; then
     extracted_binary_path="${tmpdir}/${BINARY_NAME}.exe"
  else
     log_debug "Searching for ${BINARY_NAME} (or .exe) in subdirectories..."
     found_path=$(find "${tmpdir}" -name "${BINARY_NAME}" -type f -print -quit)
     if [ -z "$found_path" ] && [ "$OS" = "windows" ]; then
        found_path=$(find "${tmpdir}" -name "${BINARY_NAME}.exe" -type f -print -quit)
     fi
     if [ -n "$found_path" ]; then extracted_binary_path="$found_path"; fi
  fi

  if [ -z "$extracted_binary_path" ]; then
      log_crit "Could not find binary '${BINARY_NAME}' after extraction in ${tmpdir}"
      rm -rf "${tmpdir}"; exit 1
  fi
  log_debug "Found binary at: ${extracted_binary_path}"

  # Install the binary
  install_path="${BINDIR}/${INSTALL_BIN_NAME}"
  log_info "Installing binary to ${install_path}"
  test ! -d "${BINDIR}" && install -d "${BINDIR}"
  install "${extracted_binary_path}" "${install_path}"
  log_info "${SPEC_NAME} installation complete!"

  # --- Cleanup ---
  rm -rf "${tmpdir}"
}

# --- Main Script Logic ---
# Override log prefix
log_prefix() {
	echo "binst"
}

parse_args "$@"
execute
`
