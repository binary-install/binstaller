package main

import (
	"fmt"
)

func processGodownloader(repo, path, filename string, attestationOpts AttestationOptions, commitHash string) ([]byte, error) {
	cfg, sourceInfo, err := Load(repo, path, filename, commitHash)
	if err != nil {
		return nil, fmt.Errorf("unable to parse: %s", err)
	}
	// We only handle the first archive.
	if len(cfg.Archives) == 0 {
		return nil, fmt.Errorf("no archives found in configuration")
	}

	archive := cfg.Archives[0]

	// get archive name template
	archName, err := makeName("", archive.NameTemplate)
	if err != nil {
		return nil, fmt.Errorf("unable generate archive name: %s", err)
	}

	// Store the modified name template back to the archive
	archive.NameTemplate = "NAME=" + archName

	// get checksum name template
	checkName, err := makeName("", cfg.Checksum.NameTemplate)
	if err != nil {
		return nil, fmt.Errorf("unable generate checksum name: %s", err)
	}

	// Store the modified checksum name template
	cfg.Checksum.NameTemplate = "CHECKSUM=" + checkName
	if err != nil {
		return nil, fmt.Errorf("unable generate checksum name: %s", err)
	}

	// Create a template context with the config, attestation options, and source info
	ctx := TemplateContext{
		Project:                  cfg,
		EnableGHAttestation:      attestationOpts.EnableGHAttestation,
		RequireAttestation:       attestationOpts.RequireAttestation,
		GHAttestationVerifyFlags: attestationOpts.GHAttestationVerifyFlags,
		SourceInfo:               sourceInfo,
	}

	return makeShell(shellGodownloader, ctx)
}

// nolint: lll
const shellGodownloader = `#!/bin/sh
set -e
# Code generated by goinstaller ({{ version }}) from {{ sourceInfo }}. DO NOT EDIT.
#

usage() {
  this=$1
  cat <<EOF
$this: download go binaries for {{ $.Project.Release.GitHub.Owner }}/{{ $.Project.Release.GitHub.Name }}

Usage: $this [-b] bindir [-d]{{- if .EnableGHAttestation }} [-a] [-s]{{- end }} [tag]
  -b sets bindir or installation directory, Defaults to ./bin
  -d turns on debug logging
{{- if .EnableGHAttestation }}
  -a requires attestation verification (fails if attestation is missing or invalid)
  -s skips attestation verification
{{- end }}
   [tag] is a tag from
   https://github.com/{{ $.Project.Release.GitHub.Owner }}/{{ $.Project.Release.GitHub.Name }}/releases
   If tag is missing, then the latest will be used.

 Generated by goinstaller
  https://github.com/haya14busa/goinstaller

EOF
  exit 2
}

parse_args() {
  #BINDIR is ./bin unless set be ENV
  # over-ridden by flag below

  BINDIR=${BINDIR:-./bin}
  while getopts "b:dh?x{{- if .EnableGHAttestation }}as{{- end }}" arg; do
    case "$arg" in
      b) BINDIR="$OPTARG" ;;
      d) log_set_priority 10 ;;
      h | \?) usage "$0" ;;
      x) set -x ;;
      {{- if .EnableGHAttestation }}
      a) REQUIRE_ATTESTATION=true ;;
      s) VERIFY_ATTESTATION=false ;;
      {{- end }}
    esac
  done
  shift $((OPTIND - 1))
  TAG=$1
}
{{- if .EnableGHAttestation }}
# verify_attestation verifies the attestation for a binary
verify_attestation() {
  local binary=$1
  local repo=$2
  local extra_flags=$3

  if is_command gh; then
    log_info "Using GitHub CLI for attestation verification"

    # Use the extra flags if provided, otherwise use the repo
    if [ -n "$extra_flags" ]; then
      if gh attestation verify "${binary}" ${extra_flags}; then
        log_info "Attestation verification successful"
        return 0
      else
        log_err "Attestation verification failed"
        return 1
      fi
    # Basic verification with repository information
    elif [ -n "$repo" ]; then
      if gh attestation verify --repo="${repo}" "${binary}"; then
        log_info "Attestation verification successful"
        return 0
      else
        log_err "Attestation verification failed"
        return 1
      fi
    else
      log_err "Repository information required for attestation verification"
      return 1
    fi
  else
    log_warn "GitHub CLI not available, skipping attestation verification"
    log_warn "For enhanced security, install GitHub CLI: https://cli.github.com/"

    # If attestation is required, fail the installation
    if [ "${REQUIRE_ATTESTATION}" = "true" ]; then
      log_err "Attestation verification required but GitHub CLI is not available"
      return 1
    fi

    # Otherwise, continue with a warning
    return 0
  fi
}
{{- end }}

# this function wraps all the destructive operations
# if a curl|bash cuts off the end of the script due to
# network, either nothing will happen or will syntax error
# out preventing half-done work
execute() {
  tmpdir=$(mktemp -d)
  log_debug "downloading files into ${tmpdir}"
  http_download "${tmpdir}/${TARBALL}" "${TARBALL_URL}"
  http_download "${tmpdir}/${CHECKSUM}" "${CHECKSUM_URL}"
  hash_sha256_verify "${tmpdir}/${TARBALL}" "${tmpdir}/${CHECKSUM}"

  {{- if .EnableGHAttestation }}
  # Verify attestation if enabled
  if [ "${VERIFY_ATTESTATION}" = "true" ]; then
    # Verify attestation
    extra_flags="${GH_ATTESTATION_VERIFY_FLAGS:-${DEFAULT_GH_ATTESTATION_VERIFY_FLAGS}}"
    if ! verify_attestation "${tmpdir}/${TARBALL}" "${OWNER}/${REPO}" "${extra_flags}"; then
      log_crit "Attestation verification failed"
      rm -rf "${tmpdir}"
      exit 1
    fi
    log_info "Attestation verification successful"
  fi
  {{- end }}

  {{- if (index .Project.Archives 0).WrapInDirectory }}
  srcdir="${tmpdir}/${NAME}"
  rm -rf "${srcdir}"
  {{- else }}
  srcdir="${tmpdir}"
  {{- end }}
  (cd "${tmpdir}" && untar "${TARBALL}")
  test ! -d "${BINDIR}" && install -d "${BINDIR}"
  for binexe in $BINARIES; do
    if [ "$OS" = "windows" ]; then
      binexe="${binexe}.exe"
    fi
    install "${srcdir}/${binexe}" "${BINDIR}/"
    log_info "installed ${BINDIR}/${binexe}"
  done
  rm -rf "${tmpdir}"
}
get_binaries() {
  case "$PLATFORM" in
  {{- range $platform, $binaries := (platformBinaries .) }}
    {{ $platform }}) BINARIES="{{ join $binaries " " }}" ;;
  {{- end }}
    *)
      log_crit "platform $PLATFORM is not supported.  Make sure this script is up-to-date and file request at https://github.com/${PREFIX}/issues/new"
      exit 1
      ;;
  esac
}
tag_to_version() {
  if [ -z "${TAG}" ]; then
    log_info "checking GitHub for latest tag"
  else
    log_info "checking GitHub for tag '${TAG}'"
  fi
  REALTAG=$(github_release "$OWNER/$REPO" "${TAG}") && true
  if test -z "$REALTAG"; then
    log_crit "unable to find '${TAG}' - use 'latest' or see https://github.com/${PREFIX}/releases for details"
    exit 1
  fi
  # if version starts with 'v', remove it
  TAG="$REALTAG"
  VERSION=${TAG#v}
}
adjust_format() {
  # change format (tar.gz or zip) based on OS
  {{- with (index .Project.Archives 0).FormatOverrides }}
  case ${OS} in
  {{- range . }}
    {{- if .Format }}
    {{ .Goos }}) FORMAT={{ .Format }} ;;
    {{- else if .Formats }}
    {{ .Goos }}) FORMAT={{ index .Formats 0 }} ;;
    {{- end }}
 {{- end }}
  esac
  {{- end }}
  true
}
adjust_os() {
  # adjust archive name based on OS
  {{- if or (contains (index .Project.Archives 0).NameTemplate "title .Os") (contains (index .Project.Archives 0).NameTemplate "title .OS") }}
  # This archive uses title case for OS names
  case ${OS} in
    darwin) OS=Darwin ;;
    linux) OS=Linux ;;
    windows) OS=Windows ;;
  esac
  {{- else }}
  # This archive uses lowercase OS names
  # No need to adjust OS names
  {{- end }}
  true
}
adjust_arch() {
  # adjust archive name based on ARCH and whether the template uses x86_64
  {{- if contains (index .Project.Archives 0).NameTemplate "x86_64" }}
  # This archive uses x86_64 for amd64
  case ${ARCH} in
    amd64) ARCH=x86_64 ;;
    386) ARCH=i386 ;;
  esac
  {{- else if contains (index .Project.Archives 0).NameTemplate "i386" }}
  # This archive uses i386 for 386
  case ${ARCH} in
    386) ARCH=i386 ;;
  esac
  {{- else }}
  # No need to adjust ARCH names
  {{- end }}
  true
}
` + shellfn + `
PROJECT_NAME="{{ $.Project.ProjectName }}"
OWNER={{ $.Project.Release.GitHub.Owner }}
REPO="{{ $.Project.Release.GitHub.Name }}"
BINARY={{ (index $.Project.Builds 0).Binary }}
FORMAT=tar.gz
OS=$(uname_os)
ARCH=$(uname_arch)
PREFIX="$OWNER/$REPO"

# use in logging routines
log_prefix() {
	echo "$PREFIX"
}
PLATFORM="${OS}/${ARCH}"
GITHUB_DOWNLOAD=https://github.com/${OWNER}/${REPO}/releases/download

{{- if .EnableGHAttestation }}
# Attestation verification configuration
{{- if .RequireAttestation }}
REQUIRE_ATTESTATION=true
{{- else }}
REQUIRE_ATTESTATION=${REQUIRE_ATTESTATION:-true}
{{- end }}
VERIFY_ATTESTATION=${VERIFY_ATTESTATION:-true}
{{- if .GHAttestationVerifyFlags }}
DEFAULT_GH_ATTESTATION_VERIFY_FLAGS="{{ .GHAttestationVerifyFlags }}"
{{- else }}
DEFAULT_GH_ATTESTATION_VERIFY_FLAGS=""
{{- end }}
{{- end }}

uname_os_check "$OS"
uname_arch_check "$ARCH"

parse_args "$@"

get_binaries

tag_to_version

adjust_format

adjust_os

adjust_arch

log_info "found version: ${VERSION} for ${TAG}/${OS}/${ARCH}"
{{ evaluateNameTemplate (index .Project.Archives 0).NameTemplate }}
TARBALL=${NAME}.${FORMAT}
TARBALL_URL=${GITHUB_DOWNLOAD}/${TAG}/${TARBALL}
{{ .Project.Checksum.NameTemplate }}
CHECKSUM_URL=${GITHUB_DOWNLOAD}/${TAG}/${CHECKSUM}

execute
`
