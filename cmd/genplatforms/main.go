package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

const outputTemplate = `// Code generated by genplatforms. DO NOT EDIT.

package asset

import (
	"github.com/binary-install/binstaller/pkg/spec"
)

// GetAllOSValues returns all possible OS values from spec constants
func GetAllOSValues() []spec.SupportedPlatformOS {
	return []spec.SupportedPlatformOS{
{{- range .OSValues }}
		spec.{{ . }},
{{- end }}
	}
}

// GetAllArchValues returns all possible Arch values from spec constants
func GetAllArchValues() []spec.SupportedPlatformArch {
	return []spec.SupportedPlatformArch{
{{- range .ArchValues }}
		spec.{{ . }},
{{- end }}
	}
}

// GetAllPlatformConstants returns all OS and Arch constants as string slices
func GetAllPlatformConstants() ([]string, []string) {
	var osValues []string
	var archValues []string

	// Convert typed constants to strings
	for _, os := range GetAllOSValues() {
		osValues = append(osValues, string(os))
	}
	
	for _, arch := range GetAllArchValues() {
		archValues = append(archValues, string(arch))
	}
	
	return osValues, archValues
}
`

type templateData struct {
	OSValues   []string
	ArchValues []string
}

func main() {
	if len(os.Args) < 3 {
		log.Fatal("Usage: genplatforms <spec-package-dir> <output-file>")
	}

	specDir := os.Args[1]
	outputFile := os.Args[2]

	// Parse the generated.go file
	generatedFile := filepath.Join(specDir, "generated.go")
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, generatedFile, nil, parser.ParseComments)
	if err != nil {
		log.Fatalf("Failed to parse %s: %v", generatedFile, err)
	}

	// Extract constants
	osValues := extractConstants(node, "SupportedPlatformOS")
	archValues := extractConstants(node, "SupportedPlatformArch")

	// Sort for consistent output
	sort.Strings(osValues)
	sort.Strings(archValues)

	// Generate code
	data := templateData{
		OSValues:   osValues,
		ArchValues: archValues,
	}

	tmpl, err := template.New("platforms").Parse(outputTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated code: %v", err)
	}

	// Write to file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}

	fmt.Printf("Generated %s with %d OS values and %d Arch values\n", outputFile, len(osValues), len(archValues))
}

// extractConstants extracts constant values of a specific type from the AST
func extractConstants(node *ast.File, typeName string) []string {
	var constants []string
	
	ast.Inspect(node, func(n ast.Node) bool {
		// Look for const declarations
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.CONST {
			return true
		}

		for _, spec := range genDecl.Specs {
			valueSpec, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}

			// Check if this constant is of the type we're looking for
			if valueSpec.Type != nil {
				typeIdent, ok := valueSpec.Type.(*ast.Ident)
				if ok && typeIdent.Name == typeName {
					// This is a constant of our target type
					for _, name := range valueSpec.Names {
						constants = append(constants, name.Name)
					}
				}
			} else {
				// Type might be inferred from the value
				// Check if any of the values is a typed constant
				for i, value := range valueSpec.Values {
					if callExpr, ok := value.(*ast.CallExpr); ok {
						if ident, ok := callExpr.Fun.(*ast.Ident); ok && ident.Name == typeName {
							// This is a typed constant
							if i < len(valueSpec.Names) {
								constants = append(constants, valueSpec.Names[i].Name)
							}
						}
					}
				}
			}
		}
		return true
	})

	// Remove duplicates and filter out non-exported constants
	seen := make(map[string]bool)
	var unique []string
	for _, c := range constants {
		if !seen[c] && isExported(c) {
			seen[c] = true
			unique = append(unique, c)
		}
	}

	return unique
}

// isExported checks if a name is exported (starts with uppercase letter)
func isExported(name string) bool {
	return len(name) > 0 && strings.ToUpper(name[:1]) == name[:1]
}