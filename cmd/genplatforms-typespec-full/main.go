package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

const outputTemplate = `// Code generated by genplatforms-typespec-full from TypeSpec source. DO NOT EDIT.

package asset

import (
	"github.com/binary-install/binstaller/pkg/spec"
)

// GetAllOSValues returns all possible OS values from spec constants
func GetAllOSValues() []spec.SupportedPlatformOS {
	return []spec.SupportedPlatformOS{
{{- range .OSValues }}
		spec.{{ . }},
{{- end }}
	}
}

// GetAllArchValues returns all possible Arch values from spec constants
func GetAllArchValues() []spec.SupportedPlatformArch {
	return []spec.SupportedPlatformArch{
{{- range .ArchValues }}
		spec.{{ . }},
{{- end }}
	}
}

// GetAllPlatformConstants returns all OS and Arch constants as string slices
func GetAllPlatformConstants() ([]string, []string) {
	var osValues []string
	var archValues []string

	// Convert typed constants to strings
	for _, os := range GetAllOSValues() {
		osValues = append(osValues, string(os))
	}
	
	for _, arch := range GetAllArchValues() {
		archValues = append(archValues, string(arch))
	}
	
	return osValues, archValues
}
`

type templateData struct {
	OSValues   []string
	ArchValues []string
}

func main() {
	if len(os.Args) < 3 {
		log.Fatal("Usage: genplatforms-typespec-full <typespec-file> <output-file>")
	}

	typespecFile := os.Args[1]
	outputFile := os.Args[2]

	// Parse the TypeSpec file
	osValues, archValues, err := parseTypeSpec(typespecFile)
	if err != nil {
		log.Fatalf("Failed to parse TypeSpec file: %v", err)
	}

	// Map the values to Go constant names
	osConstants := mapToGoConstants(osValues, osMapping)
	archConstants := mapToGoConstants(archValues, archMapping)

	// Sort for consistent output
	sort.Strings(osConstants)
	sort.Strings(archConstants)

	// Generate code
	tmplData := templateData{
		OSValues:   osConstants,
		ArchValues: archConstants,
	}

	tmpl, err := template.New("platforms").Parse(outputTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, tmplData); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format generated code: %v", err)
	}

	// Write to file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		log.Fatalf("Failed to write output file: %v", err)
	}

	fmt.Printf("Generated %s with %d OS values and %d Arch values from TypeSpec source\n", 
		outputFile, len(osConstants), len(archConstants))
}

// parseTypeSpec parses a TypeSpec file to extract OS and Arch union values
func parseTypeSpec(filename string) ([]string, []string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, nil, err
	}
	defer file.Close()

	var osValues []string
	var archValues []string
	
	scanner := bufio.NewScanner(file)
	inPlatformModel := false
	readingOS := false
	readingArch := false
	
	// Regex to match union values: | "value"
	unionValueRegex := regexp.MustCompile(`^\s*\|\s*"([^"]+)"`)
	
	for scanner.Scan() {
		line := scanner.Text()
		
		// Check if we're entering the Platform model
		if strings.Contains(line, "model Platform") {
			inPlatformModel = true
			continue
		}
		
		// Check if we're exiting the Platform model
		if inPlatformModel && strings.TrimSpace(line) == "}" {
			inPlatformModel = false
			readingOS = false
			readingArch = false
			continue
		}
		
		if inPlatformModel {
			// Check for os: field
			if strings.TrimSpace(line) == "os:" {
				readingOS = true
				readingArch = false
				continue
			}
			
			// Check for arch: field
			if strings.TrimSpace(line) == "arch:" {
				readingOS = false
				readingArch = true
				continue
			}
			
			// Check if we're ending a field (encountering a semicolon)
			if strings.Contains(line, ";") {
				readingOS = false
				readingArch = false
			}
			
			// Extract union values
			if matches := unionValueRegex.FindStringSubmatch(line); matches != nil {
				value := matches[1]
				if readingOS {
					osValues = append(osValues, value)
				} else if readingArch {
					archValues = append(archValues, value)
				}
			}
		}
	}
	
	if err := scanner.Err(); err != nil {
		return nil, nil, err
	}
	
	return osValues, archValues, nil
}

// mapToGoConstants maps TypeSpec values to Go constant names
func mapToGoConstants(values []string, mapping map[string]string) []string {
	var constants []string
	for _, value := range values {
		if goName, ok := mapping[value]; ok {
			constants = append(constants, goName)
		} else {
			log.Printf("Warning: No mapping found for value: %s", value)
		}
	}
	return constants
}

// Mapping from TypeSpec values to Go constant names
var osMapping = map[string]string{
	"linux":     "Linux",
	"darwin":    "Darwin",
	"windows":   "Windows",
	"freebsd":   "Freebsd",
	"openbsd":   "Openbsd",
	"netbsd":    "Netbsd",
	"dragonfly": "Dragonfly",
	"solaris":   "Solaris",
	"android":   "Android",
	"aix":       "AIX",
	"illumos":   "Illumos",
	"ios":       "Ios",
	"js":        "JS",
	"plan9":     "Plan9",
	"wasip1":    "Wasip1",
}

var archMapping = map[string]string{
	"amd64":    "Amd64",
	"arm64":    "Arm64",
	"386":      "The386",
	"arm":      "Arm",
	"armv5":    "Armv5",
	"armv6":    "Armv6",
	"armv7":    "Armv7",
	"ppc64":    "Ppc64",
	"ppc64le":  "Ppc64LE",
	"mips":     "MIPS",
	"mipsle":   "Mipsle",
	"mips64":   "Mips64",
	"mips64le": "Mips64LE",
	"s390x":    "S390X",
	"riscv64":  "Riscv64",
	"loong64":  "Loong64",
	"wasm":     "WASM",
	"amd64p32": "Amd64P32",
}