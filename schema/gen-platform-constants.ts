#!/usr/bin/env -S deno run --allow-read --allow-write --allow-env

import {
  compile,
  Model,
  navigateProgram,
  NodeHost,
  StringLiteral,
  Union,
} from "npm:@typespec/compiler";
import { parse } from "https://deno.land/std@0.224.0/flags/mod.ts";

interface UnionValue {
  name: string;
  value: string;
}

interface PlatformData {
  osValues: UnionValue[];
  archValues: UnionValue[];
}

/**
 * Parse TypeSpec file to extract Platform model and its OS/Arch union values
 */
async function parseTypeSpecForPlatforms(
  filePath: string,
): Promise<PlatformData> {
  const platformData: PlatformData = {
    osValues: [],
    archValues: [],
  };

  // Compile the TypeSpec file
  const program = await compile(NodeHost, filePath, {
    noEmit: true, // Just parse, don't emit output
  });

  // Check for compilation errors
  if (program.diagnostics.length > 0) {
    console.error("TypeSpec compilation errors:");
    for (const diagnostic of program.diagnostics) {
      console.error(`  ${diagnostic.message}`);
    }
    throw new Error("Failed to compile TypeSpec file");
  }

  // Navigate through all types in the program
  navigateProgram(program, {
    model(model: Model) {
      if (model.name === "Platform") {
        // Found the Platform model, extract OS and Arch unions
        for (const [propName, prop] of model.properties) {
          if (propName === "os" && prop.type.kind === "Union") {
            platformData.osValues = extractUnionValues(prop.type as Union);
          } else if (propName === "arch" && prop.type.kind === "Union") {
            platformData.archValues = extractUnionValues(prop.type as Union);
          }
        }
      }
    },
  });

  return platformData;
}

/**
 * Extract string literal values from a TypeSpec Union
 */
function extractUnionValues(union: Union): UnionValue[] {
  const values: UnionValue[] = [];

  for (const variant of union.variants.values()) {
    if (variant.type.kind === "String" && "value" in variant.type) {
      const stringLiteral = variant.type as StringLiteral;
      const value = stringLiteral.value;
      values.push({
        name: mapToGoConstantName(value),
        value: value,
      });
    }
  }

  return values;
}

/**
 * Map TypeSpec values to Go constant names
 */
function mapToGoConstantName(value: string): string {
  // Special cases
  const specialCases: Record<string, string> = {
    "aix": "AIX",
    "ios": "Ios",
    "js": "JS",
    "386": "The386",
    "ppc64le": "Ppc64LE",
    "mips": "MIPS",
    "mipsle": "Mipsle",
    "mips64": "Mips64",
    "mips64le": "Mips64LE",
    "s390x": "S390X",
    "wasm": "WASM",
    "amd64p32": "Amd64P32",
  };

  if (specialCases[value]) {
    return specialCases[value];
  }

  // Default: capitalize first letter
  return value.charAt(0).toUpperCase() + value.slice(1);
}

/**
 * Generate Go code for platform constants
 */
function generateGoCode(platformData: PlatformData): string {
  // Sort for consistent output
  const sortedOSValues = [...platformData.osValues].sort((a, b) =>
    a.name.localeCompare(b.name)
  );
  const sortedArchValues = [...platformData.archValues].sort((a, b) =>
    a.name.localeCompare(b.name)
  );

  const template =
    `// Code generated by gen-platform-constants.ts from TypeSpec source. DO NOT EDIT.

package asset

import (
	"github.com/binary-install/binstaller/pkg/spec"
)

// GetAllOSValues returns all possible OS values from spec constants
func GetAllOSValues() []spec.SupportedPlatformOS {
	return []spec.SupportedPlatformOS{
${sortedOSValues.map((v) => `		spec.${v.name},`).join("\n")}
	}
}

// GetAllArchValues returns all possible Arch values from spec constants
func GetAllArchValues() []spec.SupportedPlatformArch {
	return []spec.SupportedPlatformArch{
${sortedArchValues.map((v) => `		spec.${v.name},`).join("\n")}
	}
}

// GetAllPlatformConstants returns all OS and Arch constants as string slices
func GetAllPlatformConstants() ([]string, []string) {
	var osValues []string
	var archValues []string

	// Convert typed constants to strings
	for _, os := range GetAllOSValues() {
		osValues = append(osValues, string(os))
	}

	for _, arch := range GetAllArchValues() {
		archValues = append(archValues, string(arch))
	}

	return osValues, archValues
}
`;

  return template;
}

// Main execution
async function main() {
  const args = parse(Deno.args, {
    string: ["typespec", "output"],
    alias: {
      t: "typespec",
      o: "output",
    },
    boolean: ["help"],
    default: {
      typespec: "main.tsp",
      output: "../pkg/asset/platforms_generated.go",
    },
  });

  if (args.help) {
    console.log(`
Usage: deno run --allow-read --allow-write gen-platform-constants.ts [options]

Options:
  -t, --typespec <path>   Path to TypeSpec file (default: main.tsp)
  -o, --output <path>     Path to output Go file (default: ../pkg/asset/platforms_generated.go)
  --help                  Show this help message

Example:
  deno run --allow-read --allow-write gen-platform-constants.ts
`);
    Deno.exit(0);
  }

  const scriptDir = new URL(".", import.meta.url).pathname;
  const typespecPath = args.typespec.startsWith("/")
    ? args.typespec
    : `${scriptDir}${args.typespec}`;
  const outputPath = args.output.startsWith("/")
    ? args.output
    : `${scriptDir}${args.output}`;

  // Check if TypeSpec file exists
  try {
    await Deno.stat(typespecPath);
  } catch {
    console.error(`❌ TypeSpec file not found: ${typespecPath}`);
    Deno.exit(1);
  }

  console.log("📖 Parsing TypeSpec file for platform constants...");
  const platformData = await parseTypeSpecForPlatforms(typespecPath);

  console.log(
    `Found ${platformData.osValues.length} OS values and ${platformData.archValues.length} Arch values`,
  );

  // Generate Go code
  const goCode = generateGoCode(platformData);

  // Write to file
  await Deno.writeTextFile(outputPath, goCode);
  console.log(`✅ Generated ${outputPath}`);

  // Show what was generated
  console.log("\nGenerated constants:");
  console.log(
    "OS values:",
    platformData.osValues.map((v) => v.name).join(", "),
  );
  console.log(
    "Arch values:",
    platformData.archValues.map((v) => v.name).join(", "),
  );
}

// Run if called directly
if (import.meta.main) {
  await main();
}
